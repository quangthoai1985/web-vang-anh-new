import{g as v}from"./index-C-T-gGjb.js";import{V}from"./index-CvBqQJbG.es-BwG5Ra_W.js";function I(r){if(r)throw r}var b,T;function D(){if(T)return b;T=1;var r=Object.prototype.hasOwnProperty,t=Object.prototype.toString,i=Object.defineProperty,n=Object.getOwnPropertyDescriptor,o=function(e){return typeof Array.isArray=="function"?Array.isArray(e):t.call(e)==="[object Array]"},p=function(e){if(!e||t.call(e)!=="[object Object]")return!1;var s=r.call(e,"constructor"),c=e.constructor&&e.constructor.prototype&&r.call(e.constructor.prototype,"isPrototypeOf");if(e.constructor&&!s&&!c)return!1;var l;for(l in e);return typeof l>"u"||r.call(e,l)},f=function(e,s){i&&s.name==="__proto__"?i(e,s.name,{enumerable:!0,configurable:!0,value:s.newValue,writable:!0}):e[s.name]=s.newValue},u=function(e,s){if(s==="__proto__")if(r.call(e,s)){if(n)return n(e,s).value}else return;return e[s]};return b=function a(){var e,s,c,l,y,d,h=arguments[0],m=1,j=arguments.length,g=!1;for(typeof h=="boolean"&&(g=h,h=arguments[1]||{},m=2),(h==null||typeof h!="object"&&typeof h!="function")&&(h={});m<j;++m)if(e=arguments[m],e!=null)for(s in e)c=u(h,s),l=u(e,s),h!==l&&(g&&l&&(p(l)||(y=o(l)))?(y?(y=!1,d=c&&o(c)?c:[]):d=c&&p(c)?c:{},f(h,{name:s,newValue:a(g,d,l)})):typeof l<"u"&&f(h,{name:s,newValue:l}));return h},b}var F=D();const x=v(F);function z(r){if(typeof r!="object"||r===null)return!1;const t=Object.getPrototypeOf(r);return(t===null||t===Object.prototype||Object.getPrototypeOf(t)===null)&&!(Symbol.toStringTag in r)&&!(Symbol.iterator in r)}function _(){const r=[],t={run:i,use:n};return t;function i(...o){let p=-1;const f=o.pop();if(typeof f!="function")throw new TypeError("Expected function as last argument, not "+f);u(null,...o);function u(a,...e){const s=r[++p];let c=-1;if(a){f(a);return}for(;++c<o.length;)(e[c]===null||e[c]===void 0)&&(e[c]=o[c]);o=e,s?k(s,u)(...e):f(null,...e)}}function n(o){if(typeof o!="function")throw new TypeError("Expected `middelware` to be a function, not "+o);return r.push(o),t}}function k(r,t){let i;return n;function n(...f){const u=r.length>f.length;let a;u&&f.push(o);try{a=r.apply(this,f)}catch(e){const s=e;if(u&&i)throw s;return o(s)}u||(a&&a.then&&typeof a.then=="function"?a.then(p,o):a instanceof Error?o(a):p(a))}function o(f,...u){i||(i=!0,t(f,...u))}function p(f){o(null,f)}}const L=(function(r){const n=this.constructor.prototype,o=n[r],p=function(){return o.apply(p,arguments)};return Object.setPrototypeOf(p,n),p}),N={}.hasOwnProperty;class A extends L{constructor(){super("copy"),this.Compiler=void 0,this.Parser=void 0,this.attachers=[],this.compiler=void 0,this.freezeIndex=-1,this.frozen=void 0,this.namespace={},this.parser=void 0,this.transformers=_()}copy(){const t=new A;let i=-1;for(;++i<this.attachers.length;){const n=this.attachers[i];t.use(...n)}return t.data(x(!0,{},this.namespace)),t}data(t,i){return typeof t=="string"?arguments.length===2?(O("data",this.frozen),this.namespace[t]=i,this):N.call(this.namespace,t)&&this.namespace[t]||void 0:t?(O("data",this.frozen),this.namespace=t,this):this.namespace}freeze(){if(this.frozen)return this;const t=this;for(;++this.freezeIndex<this.attachers.length;){const[i,...n]=this.attachers[this.freezeIndex];if(n[0]===!1)continue;n[0]===!0&&(n[0]=void 0);const o=i.call(t,...n);typeof o=="function"&&this.transformers.use(o)}return this.frozen=!0,this.freezeIndex=Number.POSITIVE_INFINITY,this}parse(t){this.freeze();const i=w(t),n=this.parser||this.Parser;return P("parse",n),n(String(i),i)}process(t,i){const n=this;return this.freeze(),P("process",this.parser||this.Parser),E("process",this.compiler||this.Compiler),i?o(void 0,i):new Promise(o);function o(p,f){const u=w(t),a=n.parse(u);n.run(a,u,function(s,c,l){if(s||!c||!l)return e(s);const y=c,d=n.stringify(y,l);q(d)?l.value=d:l.result=d,e(s,l)});function e(s,c){s||!c?f(s):p?p(c):i(void 0,c)}}}processSync(t){let i=!1,n;return this.freeze(),P("processSync",this.parser||this.Parser),E("processSync",this.compiler||this.Compiler),this.process(t,o),S("processSync","process",i),n;function o(p,f){i=!0,I(p),n=f}}run(t,i,n){C(t),this.freeze();const o=this.transformers;return!n&&typeof i=="function"&&(n=i,i=void 0),n?p(void 0,n):new Promise(p);function p(f,u){const a=w(i);o.run(t,a,e);function e(s,c,l){const y=c||t;s?u(s):f?f(y):n(void 0,y,l)}}}runSync(t,i){let n=!1,o;return this.run(t,i,p),S("runSync","run",n),o;function p(f,u){I(f),o=u,n=!0}}stringify(t,i){this.freeze();const n=w(i),o=this.compiler||this.Compiler;return E("stringify",o),C(t),o(t,n)}use(t,...i){const n=this.attachers,o=this.namespace;if(O("use",this.frozen),t!=null)if(typeof t=="function")a(t,i);else if(typeof t=="object")Array.isArray(t)?u(t):f(t);else throw new TypeError("Expected usable value, not `"+t+"`");return this;function p(e){if(typeof e=="function")a(e,[]);else if(typeof e=="object")if(Array.isArray(e)){const[s,...c]=e;a(s,c)}else f(e);else throw new TypeError("Expected usable value, not `"+e+"`")}function f(e){if(!("plugins"in e)&&!("settings"in e))throw new Error("Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither");u(e.plugins),e.settings&&(o.settings=x(!0,o.settings,e.settings))}function u(e){let s=-1;if(e!=null)if(Array.isArray(e))for(;++s<e.length;){const c=e[s];p(c)}else throw new TypeError("Expected a list of plugins, not `"+e+"`")}function a(e,s){let c=-1,l=-1;for(;++c<n.length;)if(n[c][0]===e){l=c;break}if(l===-1)n.push([e,...s]);else if(s.length>0){let[y,...d]=s;const h=n[l][1];z(h)&&z(y)&&(y=x(!0,h,y)),n[l]=[e,y,...d]}}}}const $=new A().freeze();function P(r,t){if(typeof t!="function")throw new TypeError("Cannot `"+r+"` without `parser`")}function E(r,t){if(typeof t!="function")throw new TypeError("Cannot `"+r+"` without `compiler`")}function O(r,t){if(t)throw new Error("Cannot call `"+r+"` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.")}function C(r){if(!z(r)||typeof r.type!="string")throw new TypeError("Expected node, got `"+r+"`")}function S(r,t,i){if(!i)throw new Error("`"+r+"` finished async. Use `"+t+"` instead")}function w(r){return U(r)?r:new V(r)}function U(r){return!!(r&&typeof r=="object"&&"message"in r&&"messages"in r)}function q(r){return typeof r=="string"||B(r)}function B(r){return!!(r&&typeof r=="object"&&"byteLength"in r&&"byteOffset"in r)}export{$ as unified};
